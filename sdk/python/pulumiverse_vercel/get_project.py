# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = [
    'GetProjectResult',
    'AwaitableGetProjectResult',
    'get_project',
    'get_project_output',
]

@pulumi.output_type
class GetProjectResult:
    """
    A collection of values returned by getProject.
    """
    def __init__(__self__, build_command=None, dev_command=None, environments=None, framework=None, git_repository=None, id=None, ignore_command=None, install_command=None, name=None, output_directory=None, password_protection=None, public_source=None, root_directory=None, serverless_function_region=None, team_id=None, vercel_authentication=None):
        if build_command and not isinstance(build_command, str):
            raise TypeError("Expected argument 'build_command' to be a str")
        pulumi.set(__self__, "build_command", build_command)
        if dev_command and not isinstance(dev_command, str):
            raise TypeError("Expected argument 'dev_command' to be a str")
        pulumi.set(__self__, "dev_command", dev_command)
        if environments and not isinstance(environments, list):
            raise TypeError("Expected argument 'environments' to be a list")
        pulumi.set(__self__, "environments", environments)
        if framework and not isinstance(framework, str):
            raise TypeError("Expected argument 'framework' to be a str")
        pulumi.set(__self__, "framework", framework)
        if git_repository and not isinstance(git_repository, dict):
            raise TypeError("Expected argument 'git_repository' to be a dict")
        pulumi.set(__self__, "git_repository", git_repository)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if ignore_command and not isinstance(ignore_command, str):
            raise TypeError("Expected argument 'ignore_command' to be a str")
        pulumi.set(__self__, "ignore_command", ignore_command)
        if install_command and not isinstance(install_command, str):
            raise TypeError("Expected argument 'install_command' to be a str")
        pulumi.set(__self__, "install_command", install_command)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if output_directory and not isinstance(output_directory, str):
            raise TypeError("Expected argument 'output_directory' to be a str")
        pulumi.set(__self__, "output_directory", output_directory)
        if password_protection and not isinstance(password_protection, dict):
            raise TypeError("Expected argument 'password_protection' to be a dict")
        pulumi.set(__self__, "password_protection", password_protection)
        if public_source and not isinstance(public_source, bool):
            raise TypeError("Expected argument 'public_source' to be a bool")
        pulumi.set(__self__, "public_source", public_source)
        if root_directory and not isinstance(root_directory, str):
            raise TypeError("Expected argument 'root_directory' to be a str")
        pulumi.set(__self__, "root_directory", root_directory)
        if serverless_function_region and not isinstance(serverless_function_region, str):
            raise TypeError("Expected argument 'serverless_function_region' to be a str")
        pulumi.set(__self__, "serverless_function_region", serverless_function_region)
        if team_id and not isinstance(team_id, str):
            raise TypeError("Expected argument 'team_id' to be a str")
        pulumi.set(__self__, "team_id", team_id)
        if vercel_authentication and not isinstance(vercel_authentication, dict):
            raise TypeError("Expected argument 'vercel_authentication' to be a dict")
        pulumi.set(__self__, "vercel_authentication", vercel_authentication)

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> str:
        return pulumi.get(self, "build_command")

    @property
    @pulumi.getter(name="devCommand")
    def dev_command(self) -> str:
        return pulumi.get(self, "dev_command")

    @property
    @pulumi.getter
    def environments(self) -> Sequence['outputs.GetProjectEnvironmentResult']:
        return pulumi.get(self, "environments")

    @property
    @pulumi.getter
    def framework(self) -> str:
        return pulumi.get(self, "framework")

    @property
    @pulumi.getter(name="gitRepository")
    def git_repository(self) -> 'outputs.GetProjectGitRepositoryResult':
        return pulumi.get(self, "git_repository")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ignoreCommand")
    def ignore_command(self) -> str:
        return pulumi.get(self, "ignore_command")

    @property
    @pulumi.getter(name="installCommand")
    def install_command(self) -> str:
        return pulumi.get(self, "install_command")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="outputDirectory")
    def output_directory(self) -> str:
        return pulumi.get(self, "output_directory")

    @property
    @pulumi.getter(name="passwordProtection")
    def password_protection(self) -> Optional['outputs.GetProjectPasswordProtectionResult']:
        return pulumi.get(self, "password_protection")

    @property
    @pulumi.getter(name="publicSource")
    def public_source(self) -> bool:
        return pulumi.get(self, "public_source")

    @property
    @pulumi.getter(name="rootDirectory")
    def root_directory(self) -> str:
        return pulumi.get(self, "root_directory")

    @property
    @pulumi.getter(name="serverlessFunctionRegion")
    def serverless_function_region(self) -> str:
        return pulumi.get(self, "serverless_function_region")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="vercelAuthentication")
    def vercel_authentication(self) -> 'outputs.GetProjectVercelAuthenticationResult':
        return pulumi.get(self, "vercel_authentication")


class AwaitableGetProjectResult(GetProjectResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetProjectResult(
            build_command=self.build_command,
            dev_command=self.dev_command,
            environments=self.environments,
            framework=self.framework,
            git_repository=self.git_repository,
            id=self.id,
            ignore_command=self.ignore_command,
            install_command=self.install_command,
            name=self.name,
            output_directory=self.output_directory,
            password_protection=self.password_protection,
            public_source=self.public_source,
            root_directory=self.root_directory,
            serverless_function_region=self.serverless_function_region,
            team_id=self.team_id,
            vercel_authentication=self.vercel_authentication)


def get_project(name: Optional[str] = None,
                password_protection: Optional[pulumi.InputType['GetProjectPasswordProtectionArgs']] = None,
                team_id: Optional[str] = None,
                opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetProjectResult:
    """
    Use this data source to access information about an existing resource.
    """
    __args__ = dict()
    __args__['name'] = name
    __args__['passwordProtection'] = password_protection
    __args__['teamId'] = team_id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('vercel:index/getProject:getProject', __args__, opts=opts, typ=GetProjectResult).value

    return AwaitableGetProjectResult(
        build_command=pulumi.get(__ret__, 'build_command'),
        dev_command=pulumi.get(__ret__, 'dev_command'),
        environments=pulumi.get(__ret__, 'environments'),
        framework=pulumi.get(__ret__, 'framework'),
        git_repository=pulumi.get(__ret__, 'git_repository'),
        id=pulumi.get(__ret__, 'id'),
        ignore_command=pulumi.get(__ret__, 'ignore_command'),
        install_command=pulumi.get(__ret__, 'install_command'),
        name=pulumi.get(__ret__, 'name'),
        output_directory=pulumi.get(__ret__, 'output_directory'),
        password_protection=pulumi.get(__ret__, 'password_protection'),
        public_source=pulumi.get(__ret__, 'public_source'),
        root_directory=pulumi.get(__ret__, 'root_directory'),
        serverless_function_region=pulumi.get(__ret__, 'serverless_function_region'),
        team_id=pulumi.get(__ret__, 'team_id'),
        vercel_authentication=pulumi.get(__ret__, 'vercel_authentication'))


@_utilities.lift_output_func(get_project)
def get_project_output(name: Optional[pulumi.Input[str]] = None,
                       password_protection: Optional[pulumi.Input[Optional[pulumi.InputType['GetProjectPasswordProtectionArgs']]]] = None,
                       team_id: Optional[pulumi.Input[Optional[str]]] = None,
                       opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetProjectResult]:
    """
    Use this data source to access information about an existing resource.
    """
    ...
